Vfunction DataUpdater(allViewModels) {\u000a    var self = this;\u000a\u000a    self.allViewModels = allViewModels;\u000a\u000a    self._socket = undefined;\u000a    self._autoReconnecting = false;\u000a    self._autoReconnectTrial = 0;\u000a    self._autoReconnectTimeouts = [0, 1, 1, 2, 3, 5, 8, 13, 20, 40, 100];\u000a    self._autoReconnectDialogIndex = 1;\u000a\u000a    self._pluginHash = undefined;\u000a\u000a    self._throttleFactor = 1;\u000a    self._baseProcessingLimit = 500.0;\u000a    self._lastProcessingTimes = [];\u000a    self._lastProcessingTimesSize = 20;\u000a\u000a    self._timelapse_popup = undefined;\u000a\u000a    self.connect = function() {\u000a        var options = {};\u000a        if (SOCKJS_DEBUG) {\u000a            options["debug"] = true;\u000a        }\u000a\u000a        self._socket = new SockJS(SOCKJS_URI, undefined, options);\u000a        self._socket.onopen = self._onconnect;\u000a        self._socket.onclose = self._onclose;\u000a        self._socket.onmessage = self._onmessage;\u000a    };\u000a\u000a    self.reconnect = function() {\u000a        self._socket.close();\u000a        delete self._socket;\u000a        self.connect();\u000a    };\u000a\u000a    self.increaseThrottle = function() {\u000a        self.setThrottle(self._throttleFactor + 1);\u000a    };\u000a\u000a    self.decreaseThrottle = function() {\u000a        if (self._throttleFactor <= 1) {\u000a            return;\u000a        }\u000a        self.setThrottle(self._throttleFactor - 1);\u000a    };\u000a\u000a    self.setThrottle = function(throttle) {\u000a        self._throttleFactor = throttle;\u000a\u000a        self._send("throttle", self._throttleFactor);\u000a        log.debug("DataUpdater: New SockJS throttle factor:", self._throttleFactor, " new processing limit:", self._baseProcessingLimit * self._throttleFactor);\u000a    };\u000a\u000a    self._send = function(message, data) {\u000a        var payload = {};\u000a        payload[message] = data;\u000a        self._socket.send(JSON.stringify(payload));\u000a    };\u000a\u000a    self._onconnect = function() {\u000a        self._autoReconnecting = false;\u000a        self._autoReconnectTrial = 0;\u000a    };\u000a\u000a    self._onclose = function(e) {\u000a        if (e.code == SOCKJS_CLOSE_NORMAL) {\u000a            return;\u000a        }\u000a        if (self._autoReconnectTrial >= self._autoReconnectDialogIndex) {\u000a            // Only consider it a real disconnect if the trial number has exceeded our threshold.\u000a\u000a            var handled = false;\u000a            _.each(self.allViewModels, function(viewModel) {\u000a                if (handled == true) {\u000a                    return;\u000a                }\u000a\u000a                if (viewModel.hasOwnProperty("onServerDisconnect")) {\u000a                    var result = viewModel.onServerDisconnect();\u000a                    if (result !== undefined && !result) {\u000a                        handled = true;\u000a                    }\u000a                }\u000a            });\u000a\u000a            if (handled) {\u000a                return;\u000a            }\u000a\u000a            showOfflineOverlay(\u000a                gettext("Server is offline"),\u000a                gettext("The server appears to be offline, at least I'm not getting any response from it. I'll try to reconnect automatically <strong>over the next couple of minutes</strong>, however you are welcome to try a manual reconnect anytime using the button below."),\u000a                self.reconnect\u000a            );\u000a        }\u000a\u000a        if (self._autoReconnectTrial < self._autoReconnectTimeouts.length) {\u000a            var timeout = self._autoReconnectTimeouts[self._autoReconnectTrial];\u000a            log.info("Reconnect trial #" + self._autoReconnectTrial + ", waiting " + timeout + "s");\u000a            setTimeout(self.reconnect, timeout * 1000);\u000a            self._autoReconnectTrial++;\u000a        } else {\u000a            self._onreconnectfailed();\u000a        }\u000a    };\u000a\u000a    self._onreconnectfailed = function() {\u000a        var handled = false;\u000a        _.each(self.allViewModels, function(viewModel) {\u000a            if (handled == true) {\u000a                return;\u000a            }\u000a\u000a            if (viewModel.hasOwnProperty("onServerDisconnect")) {\u000a                var result = viewModel.onServerDisconnect();\u000a                if (result !== undefined && !result) {\u000a                    handled = true;\u000a                }\u000a            }\u000a        });\u000a\u000a        if (handled) {\u000a            return;\u000a        }\u000a\u000a        $("#offline_overlay_title").text(gettext("Server is offline"));\u000a        $("#offline_overlay_message").html(gettext("The server appears to be offline, at least I'm not getting any response from it. I <strong>could not reconnect automatically</strong>, but you may try a manual reconnect using the button below."));\u000a    };\u000a\u000a    self._onmessage = function(e) {\u000a        for (var prop in e.data) {\u000a            if (!e.data.hasOwnProperty(prop)) {\u000a                continue;\u000a            }\u000a\u000a            var data = e.data[prop];\u000a\u000a            var gcodeUploadProgress = $("#gcode_upload_progress");\u000a            var gcodeUploadProgressBar = $(".bar", gcodeUploadProgress);\u000a\u000a            var start = new Date().getTime();\u000a            switch (prop) {\u000a                case "connected": {\u000a                    // update the current UI API key and send it with any request\u000a                    UI_API_KEY = data["apikey"];\u000a                    $.ajaxSetup({\u000a                        headers: {"X-Api-Key": UI_API_KEY}\u000a                    });\u000a\u000a                    var oldVersion = VERSION;\u000a                    VERSION = data["version"];\u000a                    DISPLAY_VERSION = data["display_version"];\u000a                    BRANCH = data["branch"];\u000a                    $("span.version").text(DISPLAY_VERSION);\u000a\u000a                    var oldPluginHash = self._pluginHash;\u000a                    self._pluginHash = data["plugin_hash"];\u000a\u000a                    if ($("#offline_overlay").is(":visible")) {\u000a                        hideOfflineOverlay();\u000a                        _.each(self.allViewModels, function(viewModel) {\u000a                            if (viewModel.hasOwnProperty("onServerReconnect")) {\u000a                                viewModel.onServerReconnect();\u000a                            } else if (viewModel.hasOwnProperty("onDataUpdaterReconnect")) {\u000a                                viewModel.onDataUpdaterReconnect();\u000a                            }\u000a                        });\u000a\u000a                        if ($('#tabs li[class="active"] a').attr("href") == "#control") {\u000a                            $("#webcam_image").attr("src", CONFIG_WEBCAM_STREAM + "?" + new Date().getTime());\u000a                        }\u000a                    } else {\u000a                        _.each(self.allViewModels, function(viewModel) {\u000a                            if (viewModel.hasOwnProperty("onServerConnect")) {\u000a                                viewModel.onServerConnect();\u000a                            }\u000a                        });\u000a                    }\u000a\u000a                    if (oldVersion != VERSION || (oldPluginHash != undefined && oldPluginHash != self._pluginHash)) {\u000a                        showReloadOverlay();\u000a                    }\u000a\u000a                    self.setThrottle(1);\u000a\u000a                    break;\u000a                }\u000a                case "history": {\u000a                    _.each(self.allViewModels, function(viewModel) {\u000a                        if (viewModel.hasOwnProperty("fromHistoryData")) {\u000a                            viewModel.fromHistoryData(data);\u000a                        }\u000a                    });\u000a                    break;\u000a                }\u000a                case "current": {\u000a                    _.each(self.allViewModels, function(viewModel) {\u000a                        if (viewModel.hasOwnProperty("fromCurrentData")) {\u000a                            viewModel.fromCurrentData(data);\u000a                        }\u000a                    });\u000a                    break;\u000a                }\u000a                case "slicingProgress": {\u000a                    gcodeUploadProgressBar.text(_.sprintf(gettext("Slicing ... (%(percentage)d%%)"), {percentage: Math.round(data["progress"])}));\u000a\u000a                    _.each(self.allViewModels, function(viewModel) {\u000a                        if (viewModel.hasOwnProperty("onSlicingProgress")) {\u000a                            viewModel.onSlicingProgress(data["slicer"], data["model_path"], data["machinecode_path"], data["progress"]);\u000a                        }\u000a                    });\u000a                    break;\u000a                }\u000a                case "event": {\u000a                    var type = data["type"];\u000a                    var payload = data["payload"];\u000a                    var html = "";\u000a                    var format = {};\u000a\u000a                    log.debug("Got event " + type + " with payload: " + JSON.stringify(payload));\u000a\u000a                    if (type == "MovieRendering") {\u000a                        if (self._timelapse_popup !== undefined) {\u000a                            self._timelapse_popup.remove();\u000a                        }\u000a                        self._timelapse_popup = new PNotify({\u000a                            title: gettext("Rendering timelapse"),\u000a                            text: _.sprintf(gettext("Now rendering timelapse %(movie_basename)s. Due to performance reasons it is not recommended to start a print job while a movie is still rendering."), payload),\u000a                            hide: false,\u000a                            callbacks: {\u000a                                before_close: function() {\u000a                                    self._timelapse_popup = undefined;\u000a                                }\u000a                            }\u000a                        });\u000a                    } else if (type == "MovieDone") {\u000a                        if (self._timelapse_popup !== undefined) {\u000a                            self._timelapse_popup.remove();\u000a                        }\u000a                        self._timelapse_popup = new PNotify({\u000a                            title: gettext("Timelapse ready"),\u000a                            text: _.sprintf(gettext("New timelapse %(movie_basename)s is done rendering."), payload),\u000a                            type: "success",\u000a                            callbacks: {\u000a                                before_close: function(notice) {\u000a                                    if (self._timelapse_popup == notice) {\u000a                                        self._timelapse_popup = undefined;\u000a                                    }\u000a                                }\u000a                            }\u000a                        });\u000a                    } else if (type == "MovieFailed") {\u000a                        html = "<p>" + _.sprintf(gettext("Rendering of timelapse %(movie_basename)s failed with return code %(returncode)s"), payload) + "</p>";\u000a                        html += pnotifyAdditionalInfo('<pre style="overflow: auto">' + payload.error + '</pre>');\u000a\u000a                        if (self._timelapse_popup !== undefined) {\u000a                            self._timelapse_popup.remove();\u000a                        }\u000a                        self._timelapse_popup = new PNotify({\u000a                            title: gettext("Rendering failed"),\u000a                            text: html,\u000a                            type: "error",\u000a                            hide: false,\u000a                            callbacks: {\u000a                                before_close: function(notice) {\u000a                                    if (self._timelapse_popup == notice) {\u000a                                        self._timelapse_popup = undefined;\u000a                                    }\u000a                                }\u000a                            }\u000a                        });\u000a                    } else if (type == "PostRollStart") {\u000a                        var title = gettext("Capturing timelapse postroll");\u000a\u000a                        var text;\u000a                        if (!payload.postroll_duration) {\u000a                            text = _.sprintf(gettext("Now capturing timelapse post roll, this will take only a moment..."), format);\u000a                        } else {\u000a                            format = {\u000a                                time: moment().add(payload.postroll_duration, "s").format("LT")\u000a                            };\u000a\u000a                            if (payload.postroll_duration > 60) {\u000a                                format.duration = _.sprintf(gettext("%(minutes)d min"), {minutes: payload.postroll_duration / 60});\u000a                                text = _.sprintf(gettext("Now capturing timelapse post roll, this will take approximately %(duration)s (so until %(time)s)..."), format);\u000a                            } else {\u000a                                format.duration = _.sprintf(gettext("%(seconds)d sec"), {seconds: payload.postroll_duration});\u000a                                text = _.sprintf(gettext("Now capturing timelapse post roll, this will take approximately %(duration)s..."), format);\u000a                            }\u000a                        }\u000a\u000a                        if (self._timelapse_popup !== undefined) {\u000a                            self._timelapse_popup.remove();\u000a                        }\u000a                        self._timelapse_popup = new PNotify({\u000a                            title: title,\u000a                            text: text,\u000a                            hide: false,\u000a                            callbacks: {\u000a                                before_close: function(notice) {\u000a                                    if (self._timelapse_popup == notice) {\u000a                                        self._timelapse_popup = undefined;\u000a                                    }\u000a                                }\u000a                            }\u000a                        });\u000a                    } else if (type == "SlicingStarted") {\u000a                        gcodeUploadProgress.addClass("progress-striped").addClass("active");\u000a                        gcodeUploadProgressBar.css("width", "100%");\u000a                        if (payload.progressAvailable) {\u000a                            gcodeUploadProgressBar.text(_.sprintf(gettext("Slicing ... (%(percentage)d%%)"), {percentage: 0}));\u000a                        } else {\u000a                            gcodeUploadProgressBar.text(gettext("Slicing ..."));\u000a                        }\u000a                    } else if (type == "SlicingDone") {\u000a                        gcodeUploadProgress.removeClass("progress-striped").removeClass("active");\u000a                        gcodeUploadProgressBar.css("width", "0%");\u000a                        gcodeUploadProgressBar.text("");\u000a                        new PNotify({title: gettext("Slicing done"), text: _.sprintf(gettext("Sliced %(stl)s to %(gcode)s, took %(time).2f seconds"), payload), type: "success"});\u000a                    } else if (type == "SlicingCancelled") {\u000a                        gcodeUploadProgress.removeClass("progress-striped").removeClass("active");\u000a                        gcodeUploadProgressBar.css("width", "0%");\u000a                        gcodeUploadProgressBar.text("");\u000a                    } else if (type == "SlicingFailed") {\u000a                        gcodeUploadProgress.removeClass("progress-striped").removeClass("active");\u000a                        gcodeUploadProgressBar.css("width", "0%");\u000a                        gcodeUploadProgressBar.text("");\u000a\u000a                        html = _.sprintf(gettext("Could not slice %(stl)s to %(gcode)s: %(reason)s"), payload);\u000a                        new PNotify({title: gettext("Slicing failed"), text: html, type: "error", hide: false});\u000a                    } else if (type == "TransferStarted") {\u000a                        gcodeUploadProgress.addClass("progress-striped").addClass("active");\u000a                        gcodeUploadProgressBar.css("width", "100%");\u000a                        gcodeUploadProgressBar.text(gettext("Streaming ..."));\u000a                    } else if (type == "TransferDone") {\u000a                        gcodeUploadProgress.removeClass("progress-striped").removeClass("active");\u000a                        gcodeUploadProgressBar.css("width", "0%");\u000a                        gcodeUploadProgressBar.text("");\u000a                        new PNotify({\u000a                            title: gettext("Streaming done"),\u000a                            text: _.sprintf(gettext("Streamed %(local)s to %(remote)s on SD, took %(time).2f seconds"), payload),\u000a                            type: "success"\u000a                        });\u000a                    } else if (type == "PrintCancelled") {\u000a                        if (payload.firmwareError) {\u000a                            new PNotify({\u000a                                title: gettext("Unhandled communication error"),\u000a                                text: _.sprintf(gettext("There was an unhandled error while talking to the printer. Due to that the ongoing print job was cancelled. Error: %(firmwareError)s"), payload),\u000a                                type: "error",\u000a                                hide: false\u000a                            });\u000a                        }\u000a                    } else if (type == "Error") {\u000a                        new PNotify({\u000a                                title: gettext("Unhandled communication error"),\u000a                                text: _.sprintf(gettext("The was an unhandled error while talking to the printer. Due to that 3DRaion disconnected. Error: %(error)s"), payload),\u000a                                type: "error",\u000a                                hide: false\u000a                        });\u000a                    }\u000a\u000a                    var legacyEventHandlers = {\u000a                        "UpdatedFiles": "onUpdatedFiles",\u000a                        "MetadataStatisticsUpdated": "onMetadataStatisticsUpdated",\u000a                        "MetadataAnalysisFinished": "onMetadataAnalysisFinished",\u000a                        "SlicingDone": "onSlicingDone",\u000a                        "SlicingCancelled": "onSlicingCancelled",\u000a                        "SlicingFailed": "onSlicingFailed"\u000a                    };\u000a                    _.each(self.allViewModels, function(viewModel) {\u000a                        if (viewModel.hasOwnProperty("onEvent" + type)) {\u000a                            viewModel["onEvent" + type](payload);\u000a                        } else if (legacyEventHandlers.hasOwnProperty(type) && viewModel.hasOwnProperty(legacyEventHandlers[type])) {\u000a                            // there might still be code that uses the old callbacks, make sure those still get called\u000a                            // but log a warning\u000a                            log.warn("View model " + viewModel.name + " is using legacy event handler " + legacyEventHandlers[type] + ", new handler is called " + legacyEventHandlers[type]);\u000a                            viewModel[legacyEventHandlers[type]](payload);\u000a                        }\u000a                    });\u000a\u000a                    break;\u000a                }\u000a                case "timelapse": {\u000a                    _.each(self.allViewModels, function(viewModel) {\u000a                        if (viewModel.hasOwnProperty("fromTimelapseData")) {\u000a                            viewModel.fromTimelapseData(data);\u000a                        }\u000a                    });\u000a                    break;\u000a                }\u000a                case "plugin": {\u000a                    _.each(self.allViewModels, function(viewModel) {\u000a                        if (viewModel.hasOwnProperty("onDataUpdaterPluginMessage")) {\u000a                            viewModel.onDataUpdaterPluginMessage(data.plugin, data.data);\u000a                        }\u000a                    })\u000a                }\u000a            }\u000a\u000a            var end = new Date().getTime();\u000a            var difference = end - start;\u000a\u000a            while (self._lastProcessingTimes.length >= self._lastProcessingTimesSize) {\u000a                self._lastProcessingTimes.shift();\u000a            }\u000a            self._lastProcessingTimes.push(difference);\u000a\u000a            var processingLimit = self._throttleFactor * self._baseProcessingLimit;\u000a            if (difference > processingLimit) {\u000a                self.increaseThrottle();\u000a                log.debug("We are slow (" + difference + " > " + processingLimit + "), reducing refresh rate");\u000a            } else if (self._throttleFactor > 1) {\u000a                var maxProcessingTime = Math.max.apply(null, self._lastProcessingTimes);\u000a                var lowerProcessingLimit = (self._throttleFactor - 1) * self._baseProcessingLimit;\u000a                if (maxProcessingTime < lowerProcessingLimit) {\u000a                    self.decreaseThrottle();\u000a                    log.debug("We are fast (" + maxProcessingTime + " < " + lowerProcessingLimit + "), increasing refresh rate");\u000a                }\u000a            }\u000a        }\u000a    };\u000a\u000a    self.connect();\u000a}\u000a\u000a;\u000a
p0
.