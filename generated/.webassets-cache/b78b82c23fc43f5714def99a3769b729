V$(function() {\u000a    function TerminalViewModel(parameters) {\u000a        var self = this;\u000a\u000a        self.loginState = parameters[0];\u000a        self.settings = parameters[1];\u000a\u000a        // TODO remove with release of 1.3.0 and switch to RaionPi.coreui usage\u000a        self.tabTracking = parameters[2];\u000a\u000a        self.tabActive = false;\u000a\u000a        self.log = ko.observableArray([]);\u000a        self.log.extend({ throttle: 500 });\u000a        self.plainLogLines = ko.observableArray([]);\u000a        self.plainLogLines.extend({ throttle: 500 });\u000a\u000a        self.buffer = ko.observable(300);\u000a        self.upperLimit = ko.observable(1499);\u000a\u000a        self.command = ko.observable(undefined);\u000a\u000a        self.isErrorOrClosed = ko.observable(undefined);\u000a        self.isOperational = ko.observable(undefined);\u000a        self.isPrinting = ko.observable(undefined);\u000a        self.isPaused = ko.observable(undefined);\u000a        self.isError = ko.observable(undefined);\u000a        self.isReady = ko.observable(undefined);\u000a        self.isLoading = ko.observable(undefined);\u000a\u000a        self.autoscrollEnabled = ko.observable(true);\u000a\u000a        self.filters = self.settings.terminalFilters;\u000a        self.filterRegex = ko.observable();\u000a\u000a        self.cmdHistory = [];\u000a        self.cmdHistoryIdx = -1;\u000a\u000a        self.enableFancyFunctionality = ko.observable(true);\u000a        self.disableTerminalLogDuringPrinting = ko.observable(false);\u000a        self.acceptableTime = 500;\u000a        self.acceptableUnfancyTime = 300;\u000a\u000a        self.forceFancyFunctionality = ko.observable(false);\u000a        self.forceTerminalLogDuringPrinting = ko.observable(false);\u000a\u000a        self.fancyFunctionality = ko.pureComputed(function() {\u000a            return self.enableFancyFunctionality() || self.forceFancyFunctionality();\u000a        });\u000a        self.terminalLogDuringPrinting = ko.pureComputed(function() {\u000a            return !self.disableTerminalLogDuringPrinting() || self.forceTerminalLogDuringPrinting();\u000a        });\u000a\u000a        self.displayedLines = ko.pureComputed(function() {\u000a            if (!self.enableFancyFunctionality()) {\u000a                return self.log();\u000a            }\u000a\u000a            var regex = self.filterRegex();\u000a            var lineVisible = function(entry) {\u000a                return regex == undefined || !entry.line.match(regex);\u000a            };\u000a\u000a            var filtered = false;\u000a            var result = [];\u000a            var lines = self.log();\u000a            _.each(lines, function(entry) {\u000a                if (lineVisible(entry)) {\u000a                    result.push(entry);\u000a                    filtered = false;\u000a                } else if (!filtered) {\u000a                    result.push(self._toInternalFormat("[...]", "filtered"));\u000a                    filtered = true;\u000a                }\u000a            });\u000a\u000a            return result;\u000a        });\u000a\u000a        self.plainLogOutput = ko.pureComputed(function() {\u000a            if (self.fancyFunctionality()) {\u000a                return;\u000a            }\u000a            return self.plainLogLines().join("\u005cn");\u000a        });\u000a\u000a        self.lineCount = ko.pureComputed(function() {\u000a            if (!self.fancyFunctionality()) {\u000a                return;\u000a            }\u000a\u000a            var regex = self.filterRegex();\u000a            var lineVisible = function(entry) {\u000a                return regex == undefined || !entry.line.match(regex);\u000a            };\u000a\u000a            var lines = self.log();\u000a            var total = lines.length;\u000a            var displayed = _.filter(lines, lineVisible).length;\u000a            var filtered = total - displayed;\u000a\u000a            if (filtered > 0) {\u000a                if (total > self.upperLimit()) {\u000a                    return _.sprintf(gettext("showing %(displayed)d lines (%(filtered)d of %(total)d total lines filtered, buffer full)"), {displayed: displayed, total: total, filtered: filtered});\u000a                } else {\u000a                    return _.sprintf(gettext("showing %(displayed)d lines (%(filtered)d of %(total)d total lines filtered)"), {displayed: displayed, total: total, filtered: filtered});\u000a                }\u000a            } else {\u000a                if (total > self.upperLimit()) {\u000a                    return _.sprintf(gettext("showing %(displayed)d lines (buffer full)"), {displayed: displayed});\u000a                } else {\u000a                    return _.sprintf(gettext("showing %(displayed)d lines"), {displayed: displayed});\u000a                }\u000a            }\u000a        });\u000a\u000a        self.autoscrollEnabled.subscribe(function(newValue) {\u000a            if (newValue) {\u000a                self.log(self.log.slice(-self.buffer()));\u000a            }\u000a        });\u000a\u000a        self.activeFilters = ko.observableArray([]);\u000a        self.activeFilters.subscribe(function(e) {\u000a            self.updateFilterRegex();\u000a        });\u000a\u000a        self.fromCurrentData = function(data) {\u000a            self._processStateData(data.state);\u000a\u000a            var start = new Date().getTime();\u000a            self._processCurrentLogData(data.logs);\u000a            var end = new Date().getTime();\u000a\u000a            var difference = end - start;\u000a            if (self.enableFancyFunctionality()) {\u000a                if (difference > self.acceptableTime) {\u000a                    self.enableFancyFunctionality(false);\u000a                    log.warn("Terminal: Detected slow client (needed " + difference + "ms for processing new log data), disabling fancy terminal functionality");\u000a                }\u000a            } else {\u000a                if (!self.disableTerminalLogDuringPrinting() && difference > self.acceptableUnfancyTime) {\u000a                    self.disableTerminalLogDuringPrinting(true);\u000a                    log.warn("Terminal: Detected very slow client (needed " + difference + "ms for processing new log data), completely disabling terminal output during printing");\u000a                }\u000a            }\u000a        };\u000a\u000a        self.fromHistoryData = function(data) {\u000a            self._processStateData(data.state);\u000a            self._processHistoryLogData(data.logs);\u000a        };\u000a\u000a        self._processCurrentLogData = function(data) {\u000a            var length = self.log().length;\u000a            if (length >= self.upperLimit()) {\u000a                return;\u000a            }\u000a\u000a            if (!self.terminalLogDuringPrinting() && self.isPrinting()) {\u000a                var last = self.plainLogLines()[self.plainLogLines().length - 1];\u000a                var disabled = "--- client too slow, log output disabled while printing ---";\u000a                if (last != disabled) {\u000a                    self.plainLogLines.push(disabled);\u000a                }\u000a                return;\u000a            }\u000a\u000a            var newData = (data.length + length > self.upperLimit())\u000a                ? data.slice(0, self.upperLimit() - length)\u000a                : data;\u000a            if (!newData) {\u000a                return;\u000a            }\u000a\u000a            if (!self.fancyFunctionality()) {\u000a                // lite version of the terminal - text output only\u000a                self.plainLogLines(self.plainLogLines().concat(newData).slice(-self.buffer()));\u000a                self.updateOutput();\u000a                return;\u000a            }\u000a\u000a            var newLog = self.log().concat(_.map(newData, function(line) { return self._toInternalFormat(line) }));\u000a            if (newData.length != data.length) {\u000a                var cutoff = "--- too many lines to buffer, cut off ---";\u000a                newLog.push(self._toInternalFormat(cutoff, "cut"));\u000a            }\u000a\u000a            if (self.autoscrollEnabled()) {\u000a                // we only keep the last <buffer> entries\u000a                newLog = newLog.slice(-self.buffer());\u000a            }\u000a            self.log(newLog);\u000a            self.updateOutput();\u000a        };\u000a\u000a        self._processHistoryLogData = function(data) {\u000a            self.plainLogLines(data);\u000a            self.log(_.map(data, function(line) { return self._toInternalFormat(line) }));\u000a            self.updateOutput();\u000a        };\u000a\u000a        self._toInternalFormat = function(line, type) {\u000a            if (type == undefined) {\u000a                type = "line";\u000a            }\u000a            return {line: line, type: type}\u000a        };\u000a\u000a        self._processStateData = function(data) {\u000a            self.isErrorOrClosed(data.flags.closedOrError);\u000a            self.isOperational(data.flags.operational);\u000a            self.isPaused(data.flags.paused);\u000a            self.isPrinting(data.flags.printing);\u000a            self.isError(data.flags.error);\u000a            self.isReady(data.flags.ready);\u000a            self.isLoading(data.flags.loading);\u000a        };\u000a\u000a        self.updateFilterRegex = function() {\u000a            var filterRegexStr = self.activeFilters().join("|").trim();\u000a            if (filterRegexStr == "") {\u000a                self.filterRegex(undefined);\u000a            } else {\u000a                self.filterRegex(new RegExp(filterRegexStr));\u000a            }\u000a            self.updateOutput();\u000a        };\u000a\u000a        self.updateOutput = function() {\u000a            if (self.tabActive && self.tabTracking.browserTabVisible && self.autoscrollEnabled()) {\u000a                self.scrollToEnd();\u000a            }\u000a        };\u000a\u000a        self.toggleAutoscroll = function() {\u000a            self.autoscrollEnabled(!self.autoscrollEnabled());\u000a        };\u000a\u000a        self.selectAll = function() {\u000a            var container = self.fancyFunctionality() ? $("#terminal-output") : $("#terminal-output-lowfi");\u000a            if (container.length) {\u000a                container.selectText();\u000a            }\u000a        };\u000a\u000a        self.scrollToEnd = function() {\u000a            var container = self.fancyFunctionality() ? $("#terminal-output") : $("#terminal-output-lowfi");\u000a            if (container.length) {\u000a                container.scrollTop(container[0].scrollHeight);\u000a            }\u000a        };\u000a\u000a        self.sendCommand = function() {\u000a            var command = self.command();\u000a            if (!command) {\u000a                return;\u000a            }\u000a\u000a            var re = /^([gmt][0-9]+)(\u005cs.*)?/;\u000a            var commandMatch = command.match(re);\u000a            if (commandMatch != null) {\u000a                command = commandMatch[1].toUpperCase() + ((commandMatch[2] !== undefined) ? commandMatch[2] : "");\u000a            }\u000a\u000a            if (command) {\u000a                $.ajax({\u000a                    url: API_BASEURL + "printer/command",\u000a                    type: "POST",\u000a                    dataType: "json",\u000a                    contentType: "application/json; charset=UTF-8",\u000a                    data: JSON.stringify({"command": command})\u000a                });\u000a\u000a                self.cmdHistory.push(command);\u000a                self.cmdHistory.slice(-300); // just to set a sane limit to how many manually entered commands will be saved...\u000a                self.cmdHistoryIdx = self.cmdHistory.length;\u000a                self.command("");\u000a            }\u000a        };\u000a\u000a        self.fakeAck = function() {\u000a            $.ajax({\u000a                url: API_BASEURL + "connection",\u000a                type: "POST",\u000a                dataType: "json",\u000a                contentType: "application/json; charset=UTF-8",\u000a                data: JSON.stringify({"command": "fake_ack"})\u000a            });\u000a        };\u000a\u000a        self.handleKeyDown = function(event) {\u000a            var keyCode = event.keyCode;\u000a\u000a            if (keyCode == 38 || keyCode == 40) {\u000a                if (keyCode == 38 && self.cmdHistory.length > 0 && self.cmdHistoryIdx > 0) {\u000a                    self.cmdHistoryIdx--;\u000a                } else if (keyCode == 40 && self.cmdHistoryIdx < self.cmdHistory.length - 1) {\u000a                    self.cmdHistoryIdx++;\u000a                }\u000a\u000a                if (self.cmdHistoryIdx >= 0 && self.cmdHistoryIdx < self.cmdHistory.length) {\u000a                    self.command(self.cmdHistory[self.cmdHistoryIdx]);\u000a                }\u000a\u000a                // prevent the cursor from being moved to the beginning of the input field (this is actually the reason\u000a                // why we do the arrow key handling in the keydown event handler, keyup would be too late already to\u000a                // prevent this from happening, causing a jumpy cursor)\u000a                return false;\u000a            }\u000a\u000a            // do not prevent default action\u000a            return true;\u000a        };\u000a\u000a        self.handleKeyUp = function(event) {\u000a            if (event.keyCode == 13) {\u000a                self.sendCommand();\u000a            }\u000a\u000a            // do not prevent default action\u000a            return true;\u000a        };\u000a\u000a        self.onAfterTabChange = function(current, previous) {\u000a            self.tabActive = current == "#term";\u000a            self.updateOutput();\u000a        };\u000a\u000a    }\u000a\u000a    OCTOPRINT_VIEWMODELS.push([\u000a        TerminalViewModel,\u000a        ["loginStateViewModel", "settingsViewModel", "tabTracking"],\u000a        "#term"\u000a    ]);\u000a});\u000a\u000a;\u000a
p0
.