V$(function() {\u000a        //~~ Lodash setup\u000a\u000a        _.mixin({"sprintf": sprintf, "vsprintf": vsprintf});\u000a\u000a        //~~ Logging setup\u000a\u000a        log.setLevel(CONFIG_DEBUG ? "debug" : "info");\u000a\u000a        //~~ setup browser and internal tab tracking (in 1.3.0 that will be\u000a        //   much nicer with the global RaionPi object...)\u000a\u000a        var tabTracking = (function() {\u000a            var exports = {\u000a                browserTabVisibility: undefined,\u000a                selectedTab: undefined\u000a            };\u000a\u000a            var browserVisibilityCallbacks = [];\u000a\u000a            var getHiddenProp = function() {\u000a                var prefixes = ["webkit", "moz", "ms", "o"];\u000a\u000a                // if "hidden" is natively supported just return it\u000a                if ("hidden" in document) {\u000a                    return "hidden"\u000a                }\u000a\u000a                // otherwise loop over all the known prefixes until we find one\u000a                var vendorPrefix = _.find(prefixes, function(prefix) {\u000a                    return (prefix + "Hidden" in document);\u000a                });\u000a                if (vendorPrefix !== undefined) {\u000a                    return vendorPrefix + "Hidden";\u000a                }\u000a\u000a                // nothing found\u000a                return undefined;\u000a            };\u000a\u000a            var isHidden = function() {\u000a                var prop = getHiddenProp();\u000a                if (!prop) return false;\u000a\u000a                return document[prop];\u000a            };\u000a\u000a            var updateBrowserVisibility = function() {\u000a                var visible = !isHidden();\u000a                exports.browserTabVisible = visible;\u000a                _.each(browserVisibilityCallbacks, function(callback) {\u000a                    callback(visible);\u000a                })\u000a            };\u000a\u000a            // register for browser visibility tracking\u000a\u000a            var prop = getHiddenProp();\u000a            if (!prop) return undefined;\u000a\u000a            var eventName = prop.replace(/[H|h]idden/, "") + "visibilitychange";\u000a            document.addEventListener(eventName, updateBrowserVisibility);\u000a\u000a            updateBrowserVisibility();\u000a\u000a            // exports\u000a\u000a            exports.isVisible = function() { return !isHidden() };\u000a            exports.onBrowserVisibilityChange = function(callback) {\u000a                browserVisibilityCallbacks.push(callback);\u000a            };\u000a\u000a            return exports;\u000a        })();\u000a\u000a        //~~ AJAX setup\u000a\u000a        // work around a stupid iOS6 bug where ajax requests get cached and only work once, as described at\u000a        // http://stackoverflow.com/questions/12506897/is-safari-on-ios-6-caching-ajax-results\u000a        $.ajaxSetup({\u000a            type: 'POST',\u000a            headers: { "cache-control": "no-cache" }\u000a        });\u000a\u000a        // send the current UI API key with any request\u000a        $.ajaxSetup({\u000a            headers: {"X-Api-Key": UI_API_KEY}\u000a        });\u000a\u000a        //~~ Initialize file upload plugin\u000a\u000a        $.widget("blueimp.fileupload", $.blueimp.fileupload, {\u000a            options: {\u000a                dropZone: null,\u000a                pasteZone: null\u000a            }\u000a        });\u000a\u000a        //~~ Initialize i18n\u000a\u000a        var catalog = window["BABEL_TO_LOAD_" + LOCALE];\u000a        if (catalog === undefined) {\u000a            catalog = {messages: undefined, plural_expr: undefined, locale: undefined, domain: undefined}\u000a        }\u000a        babel.Translations.load(catalog).install();\u000a\u000a        moment.locale(LOCALE);\u000a\u000a        // Dummy translation requests for dynamic strings supplied by the backend\u000a        var dummyTranslations = [\u000a            // printer states\u000a            gettext("Offline"),\u000a            gettext("Opening serial port"),\u000a            gettext("Detecting serial port"),\u000a            gettext("Detecting baudrate"),\u000a            gettext("Connecting"),\u000a            gettext("Operational"),\u000a            gettext("Printing from SD"),\u000a            gettext("Sending file to SD"),\u000a            gettext("Printing"),\u000a            gettext("Paused"),\u000a            gettext("Closed"),\u000a            gettext("Transfering file to SD")\u000a        ];\u000a\u000a        //~~ Initialize PNotify\u000a\u000a        PNotify.prototype.options.styling = "bootstrap2";\u000a        PNotify.prototype.options.mouse_reset = false;\u000a\u000a        //~~ Initialize view models\u000a\u000a        // the view model map is our basic look up table for dependencies that may be injected into other view models\u000a        var viewModelMap = {};\u000a\u000a        // We put our tabTracking into the viewModelMap as a workaround until\u000a        // our global RaionPi object becomes available in 1.3.0. This way\u000a        // we'll still be able to access it in our view models.\u000a        //\u000a        // NOTE TO DEVELOPERS: Do NOT depend on this dependency in your custom\u000a        // view models. It is ONLY provided for the core application to be able\u000a        // to backport a fix from the 1.3.0 development branch and WILL BE\u000a        // REMOVED once 1.3.0 gets released without any fallback!\u000a        //\u000a        // TODO: Remove with release of 1.3.0\u000a        viewModelMap.tabTracking = tabTracking;\u000a\u000a        // Fix Function#name on browsers that do not support it (IE):\u000a        // see: http://stackoverflow.com/questions/6903762/function-name-not-supported-in-ie\u000a        if (!(function f() {}).name) {\u000a            Object.defineProperty(Function.prototype, 'name', {\u000a                get: function() {\u000a                    return this.toString().match(/^\u005cs*function\u005cs*(\u005cS*)\u005cs*\u005c(/)[1];\u000a                }\u000a            });\u000a        }\u000a\u000a        // helper to create a view model instance with injected constructor parameters from the view model map\u000a        var _createViewModelInstance = function(viewModel, viewModelMap){\u000a            var viewModelClass = viewModel[0];\u000a            var viewModelParameters = viewModel[1];\u000a\u000a            if (viewModelParameters != undefined) {\u000a                if (!_.isArray(viewModelParameters)) {\u000a                    viewModelParameters = [viewModelParameters];\u000a                }\u000a\u000a                // now we'll try to resolve all of the view model's constructor parameters via our view model map\u000a                var constructorParameters = _.map(viewModelParameters, function(parameter){\u000a                    return viewModelMap[parameter]\u000a                });\u000a            } else {\u000a                constructorParameters = [];\u000a            }\u000a\u000a            if (_.some(constructorParameters, function(parameter) { return parameter === undefined; })) {\u000a                var _extractName = function(entry) { return entry[0]; };\u000a                var _onlyUnresolved = function(entry) { return entry[1] === undefined; };\u000a                var missingParameters = _.map(_.filter(_.zip(viewModelParameters, constructorParameters), _onlyUnresolved), _extractName);\u000a                log.debug("Postponing", viewModel[0].name, "due to missing parameters:", missingParameters);\u000a                return;\u000a            }\u000a\u000a            // if we came this far then we could resolve all constructor parameters, so let's construct that view model\u000a            log.debug("Constructing", viewModel[0].name, "with parameters:", viewModelParameters);\u000a            return new viewModelClass(constructorParameters);\u000a        };\u000a\u000a        // map any additional view model bindings we might need to make\u000a        var additionalBindings = {};\u000a        _.each(OCTOPRINT_ADDITIONAL_BINDINGS, function(bindings) {\u000a            var viewModelId = bindings[0];\u000a            var viewModelBindTargets = bindings[1];\u000a            if (!_.isArray(viewModelBindTargets)) {\u000a                viewModelBindTargets = [viewModelBindTargets];\u000a            }\u000a\u000a            if (!additionalBindings.hasOwnProperty(viewModelId)) {\u000a                additionalBindings[viewModelId] = viewModelBindTargets;\u000a            } else {\u000a                additionalBindings[viewModelId] = additionalBindings[viewModelId].concat(viewModelBindTargets);\u000a            }\u000a        });\u000a\u000a        // helper for translating the name of a view model class into an identifier for the view model map\u000a        var _getViewModelId = function(viewModel){\u000a            var name = viewModel[0].name;\u000a            return name.substr(0, 1).toLowerCase() + name.substr(1); // FooBarViewModel => fooBarViewModel\u000a        };\u000a\u000a        // instantiation loop, will make multiple passes over the list of unprocessed view models until all\u000a        // view models have been successfully instantiated with all of their dependencies or no changes can be made\u000a        // any more which means not all view models can be instantiated due to missing dependencies\u000a        var unprocessedViewModels = OCTOPRINT_VIEWMODELS.slice();\u000a        unprocessedViewModels = unprocessedViewModels.concat(ADDITIONAL_VIEWMODELS);\u000a\u000a        var allViewModels = [];\u000a        var allViewModelData = [];\u000a        var pass = 1;\u000a        log.info("Starting dependency resolution...");\u000a        while (unprocessedViewModels.length > 0) {\u000a            log.debug("Dependency resolution, pass #" + pass);\u000a            var startLength = unprocessedViewModels.length;\u000a            var postponed = [];\u000a\u000a            // now try to instantiate every one of our as of yet unprocessed view model descriptors\u000a            while (unprocessedViewModels.length > 0){\u000a                var viewModel = unprocessedViewModels.shift();\u000a                var viewModelId = _getViewModelId(viewModel);\u000a\u000a                // make sure that we don't have two view models going by the same name\u000a                if (_.has(viewModelMap, viewModelId)) {\u000a                    log.error("Duplicate name while instantiating " + viewModelId);\u000a                    continue;\u000a                }\u000a\u000a                var viewModelInstance = _createViewModelInstance(viewModel, viewModelMap);\u000a\u000a                // our view model couldn't yet be instantiated, so postpone it for a bit\u000a                if (viewModelInstance === undefined) {\u000a                    postponed.push(viewModel);\u000a                    continue;\u000a                }\u000a\u000a                // we could resolve the depdendencies and the view model is not defined yet => add it, it's now fully processed\u000a                var viewModelBindTargets = viewModel[2];\u000a                if (!_.isArray(viewModelBindTargets)) {\u000a                    viewModelBindTargets = [viewModelBindTargets];\u000a                }\u000a\u000a                if (additionalBindings.hasOwnProperty(viewModelId)) {\u000a                    viewModelBindTargets = viewModelBindTargets.concat(additionalBindings[viewModelId]);\u000a                }\u000a\u000a                allViewModelData.push([viewModelInstance, viewModelBindTargets]);\u000a                allViewModels.push(viewModelInstance);\u000a                viewModelMap[viewModelId] = viewModelInstance;\u000a            }\u000a\u000a            // anything that's now in the postponed list has to be readded to the unprocessedViewModels\u000a            unprocessedViewModels = unprocessedViewModels.concat(postponed);\u000a\u000a            // if we still have the same amount of items in our list of unprocessed view models it means that we\u000a            // couldn't instantiate any more view models over a whole iteration, which in turn mean we can't resolve the\u000a            // dependencies of remaining ones, so log that as an error and then quit the loop\u000a            if (unprocessedViewModels.length == startLength) {\u000a                log.error("Could not instantiate the following view models due to unresolvable dependencies:");\u000a                _.each(unprocessedViewModels, function(entry) {\u000a                    log.error(entry[0].name + " (missing: " + _.filter(entry[1], function(id) { return !_.has(viewModelMap, id); }).join(", ") + " )");\u000a                });\u000a                break;\u000a            }\u000a\u000a            log.debug("Dependency resolution pass #" + pass + " finished, " + unprocessedViewModels.length + " view models left to process");\u000a            pass++;\u000a        }\u000a        log.info("... dependency resolution done");\u000a\u000a        var dataUpdater = new DataUpdater(allViewModels);\u000a\u000a        //~~ Custom knockout.js bindings\u000a\u000a        ko.bindingHandlers.popover = {\u000a            init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\u000a                var val = ko.utils.unwrapObservable(valueAccessor());\u000a\u000a                var options = {\u000a                    title: val.title,\u000a                    animation: val.animation,\u000a                    placement: val.placement,\u000a                    trigger: val.trigger,\u000a                    delay: val.delay,\u000a                    content: val.content,\u000a                    html: val.html\u000a                };\u000a                $(element).popover(options);\u000a            }\u000a        };\u000a\u000a        ko.bindingHandlers.allowBindings = {\u000a            init: function (elem, valueAccessor) {\u000a                return { controlsDescendantBindings: !valueAccessor() };\u000a            }\u000a        };\u000a        ko.virtualElements.allowedBindings.allowBindings = true;\u000a\u000a        ko.bindingHandlers.slimScrolledForeach = {\u000a            init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\u000a                return ko.bindingHandlers.foreach.init(element, valueAccessor(), allBindings, viewModel, bindingContext);\u000a            },\u000a            update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\u000a                setTimeout(function() {\u000a                    $(element).slimScroll({scrollBy: 0});\u000a                }, 10);\u000a                return ko.bindingHandlers.foreach.update(element, valueAccessor(), allBindings, viewModel, bindingContext);\u000a            }\u000a        };\u000a\u000a        ko.bindingHandlers.qrcode = {\u000a            update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\u000a                var val = ko.utils.unwrapObservable(valueAccessor());\u000a\u000a                var defaultOptions = {\u000a                    text: "",\u000a                    size: 200,\u000a                    fill: "#000",\u000a                    background: null,\u000a                    label: "",\u000a                    fontname: "sans",\u000a                    fontcolor: "#000",\u000a                    radius: 0,\u000a                    ecLevel: "L"\u000a                };\u000a\u000a                var options = {};\u000a                _.each(defaultOptions, function(value, key) {\u000a                    options[key] = ko.utils.unwrapObservable(val[key]) || value;\u000a                });\u000a\u000a                $(element).empty().qrcode(options);\u000a            }\u000a        };\u000a\u000a        ko.bindingHandlers.invisible = {\u000a            init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\u000a                if (!valueAccessor()) return;\u000a                ko.bindingHandlers.style.update(element, function() {\u000a                    return { visibility: 'hidden' };\u000a                })\u000a            }\u000a        };\u000a\u000a        ko.bindingHandlers.contextMenu = {\u000a            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\u000a                var val = ko.utils.unwrapObservable(valueAccessor());\u000a\u000a                $(element).contextMenu(val);\u000a            },\u000a            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\u000a                var val = ko.utils.unwrapObservable(valueAccessor());\u000a\u000a                $(element).contextMenu(val);\u000a            }\u000a        };\u000a\u000a        // Originally from Knockstrap\u000a        // https://github.com/faulknercs/Knockstrap/blob/master/src/bindings/toggleBinding.js\u000a        // License: MIT\u000a        ko.bindingHandlers.toggle = {\u000a            init: function (element, valueAccessor) {\u000a                var value = valueAccessor();\u000a\u000a                if (!ko.isObservable(value)) {\u000a                    throw new Error('toggle binding should be used only with observable values');\u000a                }\u000a\u000a                $(element).on('click', function (event) {\u000a                    event.preventDefault();\u000a\u000a                    var previousValue = ko.utils.unwrapObservable(value);\u000a                    value(!previousValue);\u000a                });\u000a            },\u000a\u000a            update: function (element, valueAccessor) {\u000a                ko.utils.toggleDomNodeCssClass(element, 'active', ko.utils.unwrapObservable(valueAccessor()));\u000a            }\u000a        };\u000a\u000a        //~~ some additional hooks and initializations\u000a\u000a        // make sure modals max out at the window height\u000a        $.fn.modal.defaults.maxHeight = function(){\u000a            // subtract the height of the modal header and footer\u000a            return $(window).height() - 165;\u000a        };\u000a\u000a        // jquery plugin to select all text in an element\u000a        // originally from: http://stackoverflow.com/a/987376\u000a        $.fn.selectText = function() {\u000a            var doc = document;\u000a            var element = this[0];\u000a            var range, selection;\u000a\u000a            if (doc.body.createTextRange) {\u000a                range = document.body.createTextRange();\u000a                range.moveToElementText(element);\u000a                range.select();\u000a            } else if (window.getSelection) {\u000a                selection = window.getSelection();\u000a                range = document.createRange();\u000a                range.selectNodeContents(element);\u000a                selection.removeAllRanges();\u000a                selection.addRange(range);\u000a            }\u000a        };\u000a\u000a        $.fn.isChildOf = function (element) {\u000a            return $(element).has(this).length > 0;\u000a        };\u000a\u000a        // from http://jsfiddle.net/KyleMit/X9tgY/\u000a        $.fn.contextMenu = function (settings) {\u000a            return this.each(function () {\u000a                // Open context menu\u000a                $(this).on("contextmenu", function (e) {\u000a                    // return native menu if pressing control\u000a                    if (e.ctrlKey) return;\u000a\u000a                    $(settings.menuSelector)\u000a                        .data("invokedOn", $(e.target))\u000a                        .data("contextParent", $(this))\u000a                        .show()\u000a                        .css({\u000a                            position: "fixed",\u000a                            left: getMenuPosition(e.clientX, 'width', 'scrollLeft'),\u000a                            top: getMenuPosition(e.clientY, 'height', 'scrollTop'),\u000a                            "z-index": 9999\u000a                        }).off('click')\u000a                        .on('click', function (e) {\u000a                            if (e.target.tagName.toLowerCase() == "input")\u000a                                return;\u000a\u000a                            $(this).hide();\u000a\u000a                            settings.menuSelected.call(this, $(this).data('invokedOn'), $(this).data('contextParent'), $(e.target));\u000a                        });\u000a\u000a                    return false;\u000a                });\u000a\u000a                //make sure menu closes on any click\u000a                $(document).click(function () {\u000a                    $(settings.menuSelector).hide();\u000a                });\u000a            });\u000a\u000a            function getMenuPosition(mouse, direction, scrollDir) {\u000a                var win = $(window)[direction](),\u000a                    scroll = $(window)[scrollDir](),\u000a                    menu = $(settings.menuSelector)[direction](),\u000a                    position = mouse + scroll;\u000a\u000a                // opening menu would pass the side of the page\u000a                if (mouse + menu > win && menu < mouse)\u000a                    position -= menu;\u000a\u000a                return position;\u000a            }\u000a        };\u000a\u000a        // Use bootstrap tabdrop for tabs and pills\u000a        $('.nav-pills, .nav-tabs').tabdrop();\u000a\u000a        // Allow components to react to tab change\u000a        var onTabChange = function(current, previous) {\u000a            log.debug("Selected RaionPi tab changed: previous = " + previous + ", current = " + current);\u000a            tabTracking.selectedTab = current;\u000a\u000a            _.each(allViewModels, function(viewModel) {\u000a                if (viewModel.hasOwnProperty("onTabChange")) {\u000a                    viewModel.onTabChange(current, previous);\u000a                }\u000a            });\u000a        };\u000a\u000a        var tabs = $('#tabs a[data-toggle="tab"]');\u000a        tabs.on('show', function (e) {\u000a            var current = e.target.hash;\u000a            var previous = e.relatedTarget.hash;\u000a            onTabChange(current, previous);\u000a        });\u000a\u000a        tabs.on('shown', function (e) {\u000a            var current = e.target.hash;\u000a            var previous = e.relatedTarget.hash;\u000a\u000a            _.each(allViewModels, function(viewModel) {\u000a                if (viewModel.hasOwnProperty("onAfterTabChange")) {\u000a                    viewModel.onAfterTabChange(current, previous);\u000a                }\u000a            });\u000a        });\u000a\u000a        onTabChange(OCTOPRINT_INITIAL_TAB);\u000a\u000a        // Fix input element click problems on dropdowns\u000a        $(".dropdown input, .dropdown label").click(function(e) {\u000a            e.stopPropagation();\u000a        });\u000a\u000a        // prevent default action for drag-n-drop\u000a        $(document).bind("drop dragover", function (e) {\u000a            e.preventDefault();\u000a        });\u000a\u000a        // reload overlay\u000a        $("#reloadui_overlay_reload").click(function() { location.reload(); });\u000a\u000a        //~~ Starting up the app\u000a\u000a        _.each(allViewModels, function(viewModel) {\u000a            if (viewModel.hasOwnProperty("onStartup")) {\u000a                viewModel.onStartup();\u000a            }\u000a        });\u000a\u000a        //~~ view model binding\u000a\u000a        var bindViewModels = function() {\u000a            log.info("Going to bind " + allViewModelData.length + " view models...");\u000a            _.each(allViewModelData, function(viewModelData) {\u000a                if (!Array.isArray(viewModelData) || viewModelData.length != 2) {\u000a                    return;\u000a                }\u000a\u000a                var viewModel = viewModelData[0];\u000a                var targets = viewModelData[1];\u000a\u000a                if (targets === undefined) {\u000a                    return;\u000a                }\u000a\u000a                if (!_.isArray(targets)) {\u000a                    targets = [targets];\u000a                }\u000a\u000a                if (viewModel.hasOwnProperty("onBeforeBinding")) {\u000a                    viewModel.onBeforeBinding();\u000a                }\u000a\u000a                if (targets != undefined) {\u000a                    if (!_.isArray(targets)) {\u000a                        targets = [targets];\u000a                    }\u000a\u000a                    _.each(targets, function(target) {\u000a                        if (target == undefined) {\u000a                            return;\u000a                        }\u000a\u000a                        var object;\u000a                        if (!(target instanceof jQuery)) {\u000a                            object = $(target);\u000a                        } else {\u000a                            object = target;\u000a                        }\u000a\u000a                        if (object == undefined || !object.length) {\u000a                            log.info("Did not bind view model", viewModel.constructor.name, "to target", target, "since it does not exist");\u000a                            return;\u000a                        }\u000a\u000a                        var element = object.get(0);\u000a                        if (element == undefined) {\u000a                            log.info("Did not bind view model", viewModel.constructor.name, "to target", target, "since it does not exist");\u000a                            return;\u000a                        }\u000a\u000a                        try {\u000a                            ko.applyBindings(viewModel, element);\u000a                            log.debug("View model", viewModel.constructor.name, "bound to", target);\u000a                        } catch (exc) {\u000a                            log.error("Could not bind view model", viewModel.constructor.name, "to target", target, ":", (exc.stack || exc));\u000a                        }\u000a                    });\u000a                }\u000a\u000a                if (viewModel.hasOwnProperty("onAfterBinding")) {\u000a                    viewModel.onAfterBinding();\u000a                }\u000a            });\u000a\u000a            _.each(allViewModels, function(viewModel) {\u000a                if (viewModel.hasOwnProperty("onAllBound")) {\u000a                    viewModel.onAllBound(allViewModels);\u000a                }\u000a            });\u000a            log.info("... binding done");\u000a\u000a            // startup complete\u000a            _.each(allViewModels, function(viewModel) {\u000a                if (viewModel.hasOwnProperty("onStartupComplete")) {\u000a                    viewModel.onStartupComplete();\u000a                }\u000a            });\u000a\u000a            // make sure we can track the browser tab visibility\u000a            tabTracking.onBrowserVisibilityChange(function(status) {\u000a                log.debug("Browser tab is now " + (status ? "visible" : "hidden"));\u000a                _.each(allViewModels, function(viewModel) {\u000a                    if (viewModel.hasOwnProperty("onBrowserTabVisibilityChange")) {\u000a                        viewModel.onBrowserTabVisibilityChange(status);\u000a                    }\u000a                });\u000a            });\u000a        };\u000a\u000a        if (!_.has(viewModelMap, "settingsViewModel")) {\u000a            throw new Error("settingsViewModel is missing, can't run UI")\u000a        }\u000a        viewModelMap["settingsViewModel"].requestData(bindViewModels);\u000a    }\u000a);\u000a\u000a\u000a;\u000a
p0
.